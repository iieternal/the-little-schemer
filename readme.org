* The Little Schemer 
** Daniel P. Friedman and Matthias Felleisen

I'm reading this book after completing HTDP. So consider my writings as a review of someone who has had some amount experience with Lisp language and the concepts introduced in the book beforehand. This also means, I'm noticing, that I get impatient and rush through some of the finger exercises as I'm all familiar constructing functions of the kind being introduced already. This was readily apparent in the chapters 1-3 where writing the member? and rember checks were too easy to pull off.

So far it feels like HTDP is a refined version of Little Schemer. This is felt in the way the topics are introduced. TLS is introducing it in a first principles manner and leaving a lot of room for thought and figuring out the how to work with the pieces to the programmer whereas, I felt HTDP recipes went a step further in defining the patterns that help you operate with the pieces.

This thinking was further solidified as the commandments are increasingly getting similar to the design recipes which I find to be much more elaborate and helpful towards devising the recursion patterns. There's more articulation on the part of authors in HTDP when it comes to prescribing design patterns.

  
** [[./01-toys.rkt][Chapter 1]]

Chapter 1 is a breezy ride through the primitive constructs ~atom? null? list? eq? car and cdr~

** [[.02-do-it-do-it-again-and-again-and-again.rkt][Chapter 2]]

Introduces the learner to recursion by using the basic ~lat?~ function which checks if a given data structure is entirely composed of atoms. The ~cond~ special form is introduced in this exercise and then the check for ~member?~ function is introduced and the special forms ~or~ is introduced in this context.

** [[./03-cons-the-magnificent.rkt][Chapter 3]]

Function to remove an item ~rember~ is introduced. The ~cons~ function is introduced in this context which is used to build up results. In the ~rember~ function, it is used to retain the elements after a check for equality is performed as in the ~member?~ function introduced in the previous chapter.

The chapter gets more evolved as it introduces ~firsts~ and insertion mechanisms ~insertR~ and ~insertL~. These are good exercises in building up an intuition on how to traverse, construct, and destruct lists. This is proceeded by introducing ~subst~ function that substitutes a matching atom with another. A variant of this function that does optional substitution is introduced called ~subst2~. Then ~multiinsertL~, ~multiinsertR~, ~multirember~, and ~multisubst~ are introduced that does what these functions used to do before but now instead of doing it once, it replaces all the matching atoms.

** [[./04-numbers-games.rkt][Chapter 4]]

The chapter teaches recursion on numbers. It introduces addition, multiplication, the data structure tuple which contains . numbers, and introduces a function for adding elements in a tuple piecewise (~tup+~). This is followed by defining the comparator operators: ~<~, ~>~, and ~=~. And then gets to defining the more tricky exponentiation and division functions.

~length~ and ~pick~ functions are defined that computes the length of a list and picks an element at the given index of the list along with ~rempick~ that removes element at the given length.

A function that removes all the numbers ~no-nums~ is introduced.

~eqan~ a function that checks for equality between two atoms is defined. This  ~occur~ counts the occurences of an atom in a given list. Finally a ~one?~ predicate is defined and it is used to redefine ~rempick~ introduced earlier.
  
** Chapter 5

  The fifth chapter has been highly effective. It talks about good
  practices of software engineering as well as it get's to the
  end. Prove it right, then think about connecting them, otherwise you
  are asking for a world of pain. Because you now have to track down
  where the error occurred by climbing up/down a ladder of abstraction.
  
  The way mutual recursion is introduced is in a way that it feels
  natural to employ it. But undecided if this way of approaching it
  without naming the pattern is a good method of teaching it.

  
* Log II
  
The aim is to finish the book by end of this year.

** 2 December 2019

** 52

  =CLOCK: [2019-12-02 Mon 14:11]--[2019-12-02 Mon 14:36] =>  0:30=
  
** 31

  =CLOCK: [2019-12-02 Mon 13:25]--[2019-12-02 Mon 13:55] =>  0:30=

** 1 December 2019
   
*** 21

   =CLOCK: [2019-12-01 Sun 19:27]--[2019-12-01 Sun 19:57] =>  0:30=

* Log 

** Daily

   #+BEGIN: clocktable :maxlevel 2 :scope subtree
   #+CAPTION: Clock summary at [2015-09-09 Wed 23:12]
   | Headline     | Time   |      |
   |--------------+--------+------|
   | *Total time* | *7:30* |      |
   |--------------+--------+------|
   | \_  Daily    |        | 7:30 |
   #+END:

*** 9 September 2015 (99-100)

    :LOGBOOK:

**** Page 100
    =CLOCK: [2015-09-09 Wed 22:32]--[2015-09-09 Wed 23:02] =>  0:30=
    :END:

*** 8 September 2015 - (99)

*** 7 September 2015 - (99)

*** 6 September 2015 - (76 - 99)
    Pomodoros Done: 14
    Pages: 99
    Rate: 99/14
    Remaining Pages: 94
    Pomodoros Remaining: 13.29

    :LOGBOOK:
    
    
**** Page 99
    =CLOCK: [2015-09-06 Sun 19:36]--[2015-09-06 Sun 20:06] =>  0:30=
   
**** Page 92
    =CLOCK: [2015-09-06 Sun 19:04]--[2015-09-06 Sun 19:34] =>  0:30=
    
**** Page 86
    =CLOCK: [2015-09-06 Sun 18:28]--[2015-09-06 Sun 18:58] =>  0:30=
    
**** Page 80
    =CLOCK: [2015-09-06 Sun 17:22]--[2015-09-06 Sun 17:52] =>  0:30=
    

    :END:
    
*** 5 September 2015 - 3 (45 - 76)
    Pomodoros Done: 10
    Pages: 76
    Rate: 76/10
    Remaining Pages: 117
    Pomodoros Remaining: 15.39

    :LOGBOOK:
**** Page 76
=CLOCK: [2015-09-05 Sat 20:32]--[2015-09-05 Sat 21:02] =>  0:30=

**** Page 68
=CLOCK: [2015-09-05 Sat 19:58]--[2015-09-05 Sat 20:28] =>  0:30=


**** Page 57
=CLOCK: [2015-09-05 Sat 03:58]--[2015-09-05 Sat 04:28] =>  0:30=


    :END:

*** 4 September 2015 - 2 (18 - 45)
    
    Pomodoros Done: 7
    Pages: 45
    Rate: 45/7
    Remaining Pages: 148
    Pomodoros Remaining: 23.02

    :LOGBOOK:
**** Page 45
    =CLOCK: [2015-09-04 Fri 22:27]--[2015-09-04 Fri 22:57] =>  0:30=

**** Page 34
    =CLOCK: [2015-09-04 Fri 21:53]--[2015-09-04 Fri 22:23] =>  0:30=

    :END:

*** 3 September 2015 - 2 (7 - 18)

    Pomodoros Done: 5
    Pages: 18
    Rate: 18/5
    Remaining Pages: 175
    Pomodoros Remaining: 48.61

    :LOGBOOK:
    
*** Page 18
=CLOCK: [2015-09-03 Thu 15:39]--[2015-09-03 Thu 16:09] =>  0:30=


**** Page 11
=CLOCK: [2015-09-03 Thu 12:36]--[2015-09-03 Thu 13:06] =>  0:30=


    :END:

*** 2 September 2015 - 3 (0 - 7)
    Pomodoros Done: 3
    Pages: 7
    Rate: 7/3
    Remaining Pages: 186
    Pomodoros Remaining: 79.71

    :LOGBOOK:
**** Page 7
=CLOCK: [2015-09-02 Wed 19:42]--[2015-09-02 Wed 20:12] =>  0:30=

**** Page 3
=CLOCK: [2015-09-02 Wed 19:12]--[2015-09-02 Wed 19:42] =>  0:30=

*** Front Matter
=CLOCK: [2015-09-02 Wed 18:33]--[2015-09-02 Wed 19:03] =>  0:30=


    :END:

    

** Chapterwise
   
- Frontmatter - 2
- Chapter 1: Toys - 2.5
- Chapter 2: Do It, Do It Again, and Again, and Again ... - 1
- Chapter 3: Cons the Magnificent - 3
- Chapter 4: Numbers Games - 2.5
- Chapter 5: *Oh My Gawd*: It's Full of Stars - 2.5
- Chapter 6: Shadows - 0.5
- Chapter 7: Friends and Relations
- Chapter 8: Lambda the Ultimate
- Chapter 9: ... and Again, and Again, and Again, ...
- Chapter 10: What is the Value of All of This?
- Intermission

   
** Estimate

   =<2019-11-18 Mon 03:57>= There was a long break in the continuum. But
   back on it now.

   =<2015-09-02 Wed 20:13>= - 350 Pomodoros <- <2015-09-04 Fri 22:58> This
   was seemingly wrong. I thought this to be another HTDP but looks like
   it's much smaller and almost as fundamental.

   =<2015-09-03 Thu 13:05>= - At the current rate looks like there's a
   chance to end this in 50 Pomodoros. But very unlikely.

   =<2015-09-04 Fri 22:20>= - If the rest of the chapters are as easy as
   the current ones, then I'm looking at a completion time of 75-100 Pomodoros.

   =<2015-09-04 Fri 22:57>= - Current calculation shows that only 20
   Pomodoros remains but that's only if I maintain the current breezing
   rate which is only possible because I'm familiar with the current
   recursion patterns, I have to see how quickly this escalates and to where.

   =<2015-09-05 Sat 20:29>= - Current rate shows only 16 or so pomodoros
   is required. But I'm thinking that at least 30 would be needed.

   =<2015-09-06 Sun 19:30>= - Things are requiring more effort because
   it requires more thought, but I think it's going to get easier. If
   all the chapters are as demanding, then I'm looking at a completion
   under 80 pomodoros, otherwise if it goes as easy before it's a < 40
   pomodoros job. But anywhere between 20 - 40 hours looks very likely.
